#!/usr/bin/env -S python3 -u
"""Main entry point for `slopspotter`."""

import argparse
import logging
import os
import sys
from importlib.metadata import metadata

from slopspotter import manifests
from slopspotter.constants import SLOPSPOTTER_VERSION, SUPPORTED_BROWSERS
from slopspotter.diagnostics import placeholder_response
from slopspotter.messaging import NativeMessage

logger = logging.getLogger(__name__)

logging.basicConfig(
    filename=os.path.join(
        os.path.dirname(os.path.dirname(os.path.dirname(__file__))), "log.log"
    ),
    level=logging.DEBUG,
    encoding="utf-8",
    format="%(asctime)s - PID %(process)d [%(levelname)s]: %(message)s",
)


def get_message():
    """Read a message from stdin and decode it."""
    raw_length = sys.stdin.buffer.read(4)
    if len(raw_length) == 0:
        return ""
    message_length = struct.unpack("@I", raw_length)[0]
    message = sys.stdin.buffer.read(message_length).decode("utf-8")
    return json.loads(message)


def encode_message(message_content):
    """Encode a message for transmission, given its content.

    https://docs.python.org/3/library/json.html#basic-usage

    To get the most compact JSON representation, you should specify (',', ':')
    to eliminate whitespace. We want the most compact representation because
    the browser rejects # messages that exceed 1 MB.
    """
    logging.debug("encoding message")
    encoded_content = json.dumps(message_content, separators=(",", ":")).encode("utf-8")
    encoded_length = struct.pack("@I", len(encoded_content))
    return {"length": encoded_length, "content": encoded_content}


def send_message(encoded_message):
    """Send an encoded message to stdout."""
    sys.stdout.buffer.write(encoded_message["length"])
    sys.stdout.buffer.write(encoded_message["content"])
    sys.stdout.buffer.flush()


def loop() -> int:
    """Main background function."""
    send_message(encode_message("test"))
    while True:
        received_message = get_message()
        if received_message == "ping":
            logging.debug("received ping, sending pong")
            send_message(encode_message("pong"))
            continue

        # Command envelope from extension
        if isinstance(received_message, dict) and "type" in received_message:
            cmd_type = received_message.get("type")
            if cmd_type == "check-packages":
                logging.debug("received check-packages command")
                try:
                    response = handle_check_packages(received_message.get("payload", {}))
                    send_message(encode_message(response))
                except Exception as exc:  # noqa: BLE001
                    logging.exception("failed to handle check-packages: %s", exc)
                    send_message(encode_message({"error": "backend-scoring-error"}))
                continue

        # Unknown message; ignore to allow fallback on the frontend.
        continue
    return 0


def handle_check_packages(payload: dict) -> dict:
    """Build a structured response for check-packages command.

    Placeholder scorer: returns "unknown" risk so the pipeline remains wired.
    Replace this with a real classifier to override the frontend heuristic.
    """
    snippet_id = payload.get("snippetId", "")
    packages = payload.get("packages", []) or []

    formatted = []
    for pkg in packages:
        name = pkg.get("name", "")
        language = pkg.get("language", "")
        formatted.append(
            {
                "name": name,
                "language": language,
                "result": {
                    "riskLevel": "unknown",
                    "score": None,
                    "summary": "Backend scoring not implemented; please verify manually.",
                    "metadataUrl": pkg.get("metadataUrl"),
                },
            }
        )

    return {
        "snippetId": snippet_id,
        "packages": formatted,
        "warning": "Backend scoring placeholder in native host.",
    }


def main() -> int:
    """Main entry point for `slopspotter`."""
    logging.debug("starting __main__.main()")
    parser = argparse.ArgumentParser(
        prog="slopspotter",
        description=metadata("slopspotter")["Summary"],
    )
    parser.add_argument(
        "manifest_path",
        nargs="?",
        default="",
        help="The complete path to the app manifest (generated by the extension).",
    )
    parser.add_argument(
        "browser_settings",
        nargs="?",
        default="",
        help="The extension's ID (generated by the extension).",
    )
    parser.add_argument(
        "-i",
        "--install-manifests",
        choices=SUPPORTED_BROWSERS,
        help="Set up the native host to work with the given browser.",
    )
    parser.add_argument(
        "-V",
        "--version",
        action="store_true",
        help="Print the current version and exit.",
    )
    args = parser.parse_args(sys.argv[1:])
    logging.debug("Received args: " + str(vars(args)))

    if args.version:
        print(SLOPSPOTTER_VERSION)
        return 0

    if args.install_manifests:
        manifests.install_manifests(args.install_manifests)
        return 0

    if args.manifest_path == "" or args.browser_settings == "":
        print(
            f"Invalid manifest path or settings:"
            f"\n\t- '{args.manifest_path}'"
            f"\n\t- '{args.browser_settings}'"
            "\nSee `slopspotter --help` for more information"
        )
        return 1

    native_message = NativeMessage.from_stdin()
    if native_message.content == "ping":
        logging.debug("Received ping. Sending pong...")
        response = NativeMessage.from_content("pong")
        response.to_stdout()
    elif isinstance(native_message.content, dict):
        logging.debug("Received dictionary")
        response = placeholder_response(native_message.content)
        logging.debug("Response: %s", response)
        NativeMessage.from_content(response).to_stdout()

    logging.debug("__main__.main() complete, exiting.")
    return 0


if __name__ == "__main__":
    sys.exit(main())
